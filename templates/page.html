{% extends "base.html" %}
{% block content %}
<!-- Debug: User role is {{ user['role'] }} -->
<div class="box">
  <!-- Navigation buttons at the top -->
  <div class="level mb-4">
    <div class="level-left">
      <div class="level-item">
        <div class="buttons">
          <a class="button is-light" href="{{ url_for('index') }}">Document List</a>
          <a class="button is-light" href="{{ url_for('document', doc_id=page.document_id) }}">Page List</a>
          {% if prev_page_id %}
          <a class="button is-light" href="{{ url_for('page', page_id=prev_page_id) }}">‚Üê Previous</a>
          {% endif %}
          {% if next_page_id %}
          <a class="button is-light" href="{{ url_for('page', page_id=next_page_id) }}">Next ‚Üí</a>
          {% endif %}
        </div>
      </div>
    </div>
    <div class="level-right">
      <div class="level-item">
        <p class="has-text-grey">Page {{ page.page_index + 1 }}</p>
      </div>
    </div>
  </div>

  <div class="columns">

    <!-- LEFT: Canvas and tools -->
    <div class="column is-two-thirds">
      {% if user['role'] == 'student' %}
      <div class="toolbar mb-4">
        <div class="buttons">
          <button class="button is-link is-outlined" id="tool-rect">Rectangle</button>
          <button class="button is-warning is-outlined" id="tool-line">Line</button>
          <button class="button is-success is-outlined" id="tool-freehand">Freehand</button>
          <button class="button is-info is-outlined" id="tool-text">Text</button>
          <input class="input" id="color-input" type="color" value="#000000" style="max-width:120px">
          <button class="button is-danger is-outlined" id="tool-delete">Delete</button>
        </div>
      </div>
      {% endif %}

      <div style="position:relative; display:inline-block;">
        <img id="page-img"
             src="{{ page.image_url }}"
             class="page-image">
        {% if user['role'] == 'student' %}
        <canvas id="annot-canvas" style="position:absolute; left:0; top:0; pointer-events: auto;"></canvas>
        {% endif %}
      </div>
    </div>

    <!-- RIGHT: Emoji panel -->
    <div class="column is-one-third">
      {% if user['role'] == 'student' %}
      <h2 class="title is-5">How are you feeling on this page?</h2>
      <p class="mb-3 has-text-grey">Select one emotion. Only one can be active.</p>

      <div id="emoji-panel" class="is-flex is-flex-wrap-wrap" style="gap:.75rem;">
        <button class="button is-light emoji-btn" data-emoji="ü§©" title="Excited">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">ü§©</span>
            <span style="font-size:.8rem;">Excited</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üôÇ" title="Okay/Happy">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üôÇ</span>
            <span style="font-size:.8rem;">Okay</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üòï" title="Confused">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üòï</span>
            <span style="font-size:.8rem;">Confused</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò§" title="Frustrated">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò§</span>
            <span style="font-size:.8rem;">Frustrated</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò¢" title="Overwhelmed">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò¢</span>
            <span style="font-size:.8rem;">Overwhelmed</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò¥" title="Bored/Tired">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò¥</span>
            <span style="font-size:.8rem;">Bored</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò°" title="Triggered">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò°</span>
            <span style="font-size:.8rem;">Triggered</span>
          </div>
        </button>
        <button class="button is-light emoji-btn" data-emoji="üò≤" title="Surprised">
          <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
            <span style="font-size:1.6rem;">üò≤</span>
            <span style="font-size:.8rem;">Surprised</span>
          </div>
        </button>
      </div>
      {% else %}
      <h2 class="title is-5">Student Emotions</h2>
      <p class="mb-3 has-text-grey">Emotion counts for this page:</p>

      <div class="box">
        <div class="content">
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">ü§©</span>
              </div>
              <div class="level-item">
                <span><strong>Excited</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('ü§©', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üôÇ</span>
              </div>
              <div class="level-item">
                <span><strong>Okay</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üôÇ', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üòï</span>
              </div>
              <div class="level-item">
                <span><strong>Confused</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üòï', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò§</span>
              </div>
              <div class="level-item">
                <span><strong>Frustrated</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò§', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò¢</span>
              </div>
              <div class="level-item">
                <span><strong>Overwhelmed</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò¢', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò¥</span>
              </div>
              <div class="level-item">
                <span><strong>Bored</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò¥', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò°</span>
              </div>
              <div class="level-item">
                <span><strong>Triggered</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò°', 0) }}</span>
              </div>
            </div>
          </div>
          
          <div class="level mb-3">
            <div class="level-left">
              <div class="level-item">
                <span style="font-size:1.6rem;">üò≤</span>
              </div>
              <div class="level-item">
                <span><strong>Surprised</strong></span>
              </div>
            </div>
            <div class="level-right">
              <div class="level-item">
                <span class="tag is-primary is-medium">{{ emotion_counts.get('üò≤', 0) }}</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      {% endif %}
    </div>

  </div>
</div>

{% if user['role'] == 'student' %}
{# PDF download commented out - scale issues not resolved #}
{# <div class="mt-4">
  <a href="{{ url_for('download_pdf', doc_id=page.document_id) }}" class="button is-primary is-outlined is-medium" download>Download PDF</a>
</div> #}

<!-- Text Input Modal -->
<div class="modal" id="text-modal">
  <div class="modal-background"></div>
  <div class="modal-card">
    <header class="modal-card-head">
      <p class="modal-card-title">Enter Text</p>
      <button class="delete" aria-label="close" id="close-text-modal"></button>
    </header>
    <section class="modal-card-body">
      <textarea class="textarea" id="text-modal-input" placeholder="Enter your text here (up to 6 lines)" rows="6" style="min-height: 120px;"></textarea>
    </section>
    <footer class="modal-card-foot">
      <button class="button is-primary" id="submit-text-modal">Add Text</button>
      <button class="button" id="cancel-text-modal">Cancel</button>
    </footer>
  </div>
</div>
{% endif %}

<style>
  .emoji-btn.is-selected { box-shadow: 0 0 0 2px #485fc7 inset; }
  .modal-card {
    max-width: 500px;
  }
</style>

{% if user['role'] == 'student' %}
<script>
  const pageId = {{ page.id }};
  const existing = {{ annotations|tojson }};
  let currentEmoji = {{ (current_emoji or 'null')|tojson }};

  const img = document.getElementById('page-img');
  const canvas = document.getElementById('annot-canvas');
  const ctx = canvas.getContext('2d');

  const toolRectBtn = document.getElementById('tool-rect');
  const toolTextBtn = document.getElementById('tool-text');
  const toolLineBtn = document.getElementById('tool-line');
  const toolFreehandBtn = document.getElementById('tool-freehand');
  const deleteBtn   = document.getElementById('tool-delete');
  const colorInput = document.getElementById('color-input');
  
  // Text modal elements
  const textModal = document.getElementById('text-modal');
  const textModalInput = document.getElementById('text-modal-input');
  const submitTextBtn = document.getElementById('submit-text-modal');
  const cancelTextBtn = document.getElementById('cancel-text-modal');
  const closeTextModalBtn = document.getElementById('close-text-modal');

  let tool = 'rect';
  let drawing = false;
  let startX = 0, startY = 0;
  let freehandPath = [];
  let pendingTextPosition = null; // Store x, y when text tool is clicked
  let colorInputBlurTime = 0; // Track when color input loses focus to prevent immediate canvas clicks
  let colorInputWasFocused = false; // Track if color input was recently focused

  function setActiveTool(selectedTool) {
    tool = selectedTool;
    // Remove active class and add outlined class to all buttons
    [toolRectBtn, toolTextBtn, toolLineBtn, toolFreehandBtn, deleteBtn].forEach(btn => {
      if (btn) {
        btn.classList.remove('is-active');
        btn.classList.add('is-outlined');
      }
    });
    // Add active class and remove outlined class from selected button
    if (tool === 'rect') {
      toolRectBtn.classList.add('is-active');
      toolRectBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'text') {
      toolTextBtn.classList.add('is-active');
      toolTextBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'line') {
      toolLineBtn.classList.add('is-active');
      toolLineBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'freehand') {
      toolFreehandBtn.classList.add('is-active');
      toolFreehandBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'crosshair';
    } else if (tool === 'delete') {
      deleteBtn.classList.add('is-active');
      deleteBtn.classList.remove('is-outlined');
      canvas.style.cursor = 'pointer';
    }
  }

  toolRectBtn.onclick = () => setActiveTool('rect');
  toolTextBtn.onclick = () => setActiveTool('text');
  toolLineBtn.onclick = () => setActiveTool('line');
  toolFreehandBtn.onclick = () => setActiveTool('freehand');
  deleteBtn.onclick = () => setActiveTool('delete');
  
  // Set initial active tool
  setActiveTool('freehand');

  function resizeCanvasToImage() {
    canvas.width = img.clientWidth;
    canvas.height = img.clientHeight;
    redraw();
  }
  img.addEventListener('load', resizeCanvasToImage);
  window.addEventListener('resize', resizeCanvasToImage);
  if (img.complete) resizeCanvasToImage();
  
  // Track color input focus/blur to prevent canvas clicks immediately after color selection
  colorInput.addEventListener('focus', () => {
    colorInputWasFocused = true;
  });
  
  colorInput.addEventListener('blur', () => {
    colorInputBlurTime = Date.now();
    // Keep the flag true for a short time after blur to prevent immediate canvas clicks
    // The flag will be checked in the canvas mousedown handler
    setTimeout(() => {
      colorInputWasFocused = false;
    }, 500);
  });
  
  colorInput.addEventListener('change', () => {
    colorInputBlurTime = Date.now();
  });
  
  colorInput.addEventListener('input', () => {
    colorInputBlurTime = Date.now();
  });
  
  // Also track clicks on color input directly
  colorInput.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent event from bubbling to canvas
    colorInputWasFocused = true;
  });
  
  // Text modal functions
  function showTextModal(x, y) {
    if (!textModal || !textModalInput) return;
    pendingTextPosition = { x, y };
    textModalInput.value = '';
    textModal.classList.add('is-active');
    
    // Focus the input after a short delay to ensure modal is visible
    // Use requestAnimationFrame to ensure DOM updates are complete
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        textModalInput.focus();
      });
    });
  }
  
  function hideTextModal() {
    if (!textModal || !textModalInput) return;
    textModal.classList.remove('is-active');
    pendingTextPosition = null;
    textModalInput.value = '';
  }
  
  function submitTextFromModal() {
    const txt = textModalInput.value; // Don't trim - preserve line breaks
    if (!txt || !txt.trim()) {
      hideTextModal();
      return;
    }
    
    if (!pendingTextPosition) {
      hideTextModal();
      return;
    }
    
    const x = pendingTextPosition.x;
    const y = pendingTextPosition.y;
    
    // Calculate text dimensions for wrapping (handles both explicit line breaks and word wrapping)
    ctx.font = '16px sans-serif';
    const maxWidth = canvas.width - x - 10; // Leave 10px margin from right edge
    const lineHeight = 18;
    
    // Split by actual line breaks first
    const paragraphs = txt.split('\n');
    let lineCount = 0;
    let maxLineWidth = 0;
    
    for (let paraIndex = 0; paraIndex < paragraphs.length; paraIndex++) {
      const paragraph = paragraphs[paraIndex];
      if (paragraph.trim() === '' && paraIndex < paragraphs.length - 1) {
            // Empty line
            lineCount++;
            continue;
          }
      
      // Word wrap within this paragraph
      const words = paragraph.split(' ');
      let line = '';
      
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && i > 0) {
          maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
          line = words[i] + ' ';
          lineCount++;
        } else {
          line = testLine;
          maxLineWidth = Math.max(maxLineWidth, metrics.width);
        }
      }
      
      // Count remaining line from this paragraph
      if (line.trim()) {
        lineCount++;
        maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
      }
    }
    
    // Store width and height for hit testing and display
    const textWidth = maxLineWidth;
    const textHeight = lineCount * lineHeight;
    
    saveAnnotation({ 
      kind: 'text', 
      x: x, 
      y: y, 
      w: textWidth,
      h: textHeight,
      text: txt, // Preserve line breaks
      color: colorInput.value 
    });
    
    hideTextModal();
  }
  
  // Modal event handlers - check if elements exist before adding listeners
  if (submitTextBtn) {
    submitTextBtn.addEventListener('click', submitTextFromModal);
  }
  if (cancelTextBtn) {
    cancelTextBtn.addEventListener('click', hideTextModal);
  }
  if (closeTextModalBtn) {
    closeTextModalBtn.addEventListener('click', hideTextModal);
  }
  
  // Close modal when clicking background
  if (textModal) {
    const modalBackground = textModal.querySelector('.modal-background');
    if (modalBackground) {
      modalBackground.addEventListener('click', hideTextModal);
    }
  }
  
  // Only Escape closes modal, Enter creates new line (no submit on Enter)
  if (textModalInput) {
    textModalInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideTextModal();
      }
      // Enter key is allowed to create new lines - no preventDefault or submit
    });
  }

  function drawAnnotation(a) {
    const color = a.color || '#000000';
    ctx.strokeStyle = color;
    // Increased transparency: 15 hex = ~8% opacity (was 40 = 25% opacity)
    ctx.fillStyle = a.kind === 'rect' ? `${color}15` : color;
    ctx.lineWidth = 2;

    if (a.kind === 'rect') {
      ctx.beginPath();
      ctx.rect(a.x, a.y, a.w, a.h);
      ctx.fill();
      ctx.stroke();
    } else if (a.kind === 'text') {
      ctx.font = '16px sans-serif';
      ctx.fillStyle = color;
      
      if (a.text) {
        // Handle both explicit line breaks and word wrapping
        const maxWidth = a.w || (canvas.width - a.x - 10); // Leave 10px margin from right edge
        const lineHeight = 18; // Line height for wrapped text
        let y = a.y;
        
        // Split by actual line breaks first
        const paragraphs = a.text.split('\n');
        
        for (let paraIndex = 0; paraIndex < paragraphs.length; paraIndex++) {
          const paragraph = paragraphs[paraIndex];
          if (paragraph.trim() === '' && paraIndex < paragraphs.length - 1) {
            // Empty line, just advance y
            y += lineHeight;
            continue;
          }
          
          // Word wrap within this paragraph
          const words = paragraph.split(' ');
          let line = '';
          
          for (let i = 0; i < words.length; i++) {
            const testLine = line + words[i] + ' ';
            const metrics = ctx.measureText(testLine);
            
            if (metrics.width > maxWidth && i > 0) {
              // Draw current line and start new line
              ctx.fillText(line, a.x, y);
              line = words[i] + ' ';
              y += lineHeight;
            } else {
              line = testLine;
            }
          }
          // Draw remaining line from this paragraph
          if (line.trim()) {
            ctx.fillText(line, a.x, y);
            y += lineHeight;
          }
        }
      }
    } else if (a.kind === 'line') {
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(a.x + a.w, a.y + a.h);
      ctx.stroke();
    } else if (a.kind === 'freehand') {
      // Draw freehand path from stored points
      if (a.text) {
        try {
          const path = JSON.parse(a.text);
          if (Array.isArray(path) && path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
          }
        } catch (e) {
          console.error('Error parsing freehand path:', e);
        }
      }
    }
  }

  function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    existing.forEach(drawAnnotation);
  }

  function getCanvasCoordinates(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  canvas.addEventListener('mousedown', (e) => {
    // Prevent triggering canvas actions when clicking on color input or modal
    const target = e.target;
    if (target === colorInput || target.closest('#text-modal') || target.closest('.modal')) {
      return;
    }
    
    // Check if click originated from color picker (native color input can trigger events)
    if (e.relatedTarget === colorInput || e.fromElement === colorInput) {
      return;
    }
    
    // Check if click is within toolbar area (where color input is)
    const toolbar = document.querySelector('.toolbar');
    if (toolbar && toolbar.contains(target)) {
      return;
    }
    
    // Check if color input is currently focused (color picker might still be open)
    if (document.activeElement === colorInput) {
      return;
    }
    
    // Prevent canvas clicks for 500ms after color input loses focus (to handle color picker closing)
    // Also check if color input was recently focused to catch edge cases
    const timeSinceBlur = Date.now() - colorInputBlurTime;
    if ((timeSinceBlur < 500 && colorInputBlurTime > 0) || colorInputWasFocused) {
      // Only prevent if tool is 'text' - other tools can work normally
      if (tool === 'text') {
        return;
      }
    }
    
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      drawing = true;
      freehandPath = [{x, y}];
      // Start drawing immediately
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    } else if (tool === 'rect' || tool === 'line') {
      drawing = true;
      startX = x;
      startY = y;
    } else if (tool === 'text') {
      // Show modal for text input
      showTextModal(x, y);
    } else if (tool === 'delete') {
      const id = hitTest(x, y);
      if (id != null) deleteAnnotation(id);
    }
  });

  // Touch events for stylus/mobile support
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      drawing = true;
      freehandPath = [{x, y}];
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(x, y);
    } else if (tool === 'rect' || tool === 'line') {
      drawing = true;
      startX = x;
      startY = y;
    } else if (tool === 'text') {
      // Show modal for text input
      showTextModal(x, y);
    } else if (tool === 'delete') {
      const id = hitTest(x, y);
      if (id != null) deleteAnnotation(id);
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!drawing) return;
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      freehandPath.push({x, y});
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (tool === 'rect' || tool === 'line') {
      redraw();
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      if (tool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
      if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
  });

  // Touch move for stylus/mobile support
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!drawing) return;
    const coords = getCanvasCoordinates(e);
    const x = coords.x;
    const y = coords.y;

    if (tool === 'freehand') {
      freehandPath.push({x, y});
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (tool === 'rect' || tool === 'line') {
      redraw();
      ctx.strokeStyle = colorInput.value;
      ctx.lineWidth = 2;
      if (tool === 'rect') ctx.strokeRect(startX, startY, x - startX, y - startY);
      if (tool === 'line') {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (!drawing) return;
    
    if (tool === 'freehand') {
      if (freehandPath.length > 1) {
        // Calculate bounding box for freehand drawing
        const xs = freehandPath.map(p => p.x);
        const ys = freehandPath.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const payload = {
          kind: 'freehand',
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          text: JSON.stringify(freehandPath),
          color: colorInput.value
        };
        saveAnnotation(payload);
      }
      freehandPath = [];
    } else if (tool === 'rect' || tool === 'line') {
      const coords = getCanvasCoordinates(e);
      const endX = coords.x;
      const endY = coords.y;
      const w = endX - startX;
      const h = endY - startY;

      if (Math.abs(w) < 3 && Math.abs(h) < 3) {
        drawing = false;
        return;
      }
      const payload = { kind: tool, x: startX, y: startY, w, h, color: colorInput.value };
      saveAnnotation(payload);
    }
    
    drawing = false;
  });

  // Touch end for stylus/mobile support
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (!drawing) return;
    
    if (tool === 'freehand') {
      if (freehandPath.length > 1) {
        const xs = freehandPath.map(p => p.x);
        const ys = freehandPath.map(p => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        const payload = {
          kind: 'freehand',
          x: minX,
          y: minY,
          w: maxX - minX,
          h: maxY - minY,
          text: JSON.stringify(freehandPath),
          color: colorInput.value
        };
        saveAnnotation(payload);
      }
      freehandPath = [];
    } else if (tool === 'rect' || tool === 'line') {
      const coords = getCanvasCoordinates(e);
      const endX = coords.x;
      const endY = coords.y;
      const w = endX - startX;
      const h = endY - startY;

      if (Math.abs(w) < 3 && Math.abs(h) < 3) {
        drawing = false;
        return;
      }
      const payload = { kind: tool, x: startX, y: startY, w, h, color: colorInput.value };
      saveAnnotation(payload);
    }
    
    drawing = false;
  });

  function saveAnnotation(payload) {
    fetch(`{{ url_for('annotate', page_id=page.id) }}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).then(r => r.json()).then(resp => {
      if (resp.id) {
        // Add to existing array and redraw
        existing.push(resp);
        redraw();
      }
    }).catch(err => {
      console.error('Error saving annotation:', err);
      alert('Failed to save annotation');
    });
  }

  function deleteAnnotation(id) {
    fetch(`${window.BASE_PATH || ''}/annotations/${id}`, { method: 'DELETE' })
      .then(r => r.json())
      .then(resp => { if (resp.status === 'success') location.reload(); });
  }

  function hitTest(x, y) {
    for (let i = existing.length - 1; i >= 0; i--) {
      const a = existing[i];
      if (a.kind === 'rect') {
        if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) return a.id;
      } else if (a.kind === 'text') {
        // Use stored width/height if available, otherwise calculate
        const w = a.w || (10 + (a.text ? a.text.length * 8 : 20));
        const h = a.h || 20;
        if (x >= a.x - 5 && x <= a.x + w && y >= a.y - h && y <= a.y + 5) return a.id;
      } else if (a.kind === 'line') {
        const dist = Math.abs((a.h)*(x - a.x) - (a.w)*(y - a.y)) / Math.sqrt(a.h*a.h + a.w*a.w);
        if (dist < 5) return a.id;
      } else if (a.kind === 'freehand') {
        // Check if point is near any segment of the freehand path
        if (a.text) {
          try {
            const path = JSON.parse(a.text);
            if (Array.isArray(path) && path.length > 0) {
              // Check if point is within bounding box first (quick check)
              if (x >= a.x && x <= a.x + a.w && y >= a.y && y <= a.y + a.h) {
                // Check distance to path segments
                for (let j = 0; j < path.length - 1; j++) {
                  const p1 = path[j];
                  const p2 = path[j + 1];
                  const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                  if (dist < 8) return a.id; // 8px threshold for freehand
                }
              }
            }
          } catch (e) {
            console.error('Error parsing freehand path in hitTest:', e);
          }
        }
      }
    }
    return null;
  }

  function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    if (lenSq !== 0) param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Emoji selection
  const panel = document.getElementById('emoji-panel');
  if (panel) {
    function setSelectedEmoji(emoji) {
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.classList.toggle('is-selected', btn.dataset.emoji === emoji);
      });
    }
    if (currentEmoji) setSelectedEmoji(currentEmoji);
    
    panel.addEventListener('click', (e) => {
      const btn = e.target.closest('.emoji-btn');
      if (!btn) return;
      const emoji = btn.dataset.emoji;
      const newEmoji = emoji === currentEmoji ? null : emoji;
      fetch(`${window.BASE_PATH || ''}/page/${pageId}/reaction`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({emoji: newEmoji})
      }).then(r => {
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}`);
        }
        return r.json().catch(() => {
          // If JSON parsing fails, but status was OK, assume success
          return {ok: true};
        });
      }).then(resp => {
        // Update UI regardless of response format if HTTP status was OK
        currentEmoji = newEmoji;
        setSelectedEmoji(newEmoji);
      }).catch(err => {
        console.error('Error saving reaction:', err);
        alert('Failed to save reaction. Please try again.');
      });
    });
  }
</script>
{% endif %}
{% endblock %}